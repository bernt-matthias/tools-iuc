<?xml version="1.0"?>
<macros>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@STACKS_VERSION@">stacks</requirement>
            <yield/>
        </requirements>
    </xml>

    <token name="@STACKS_VERSION@">2.2</token>
    <token name="@WRAPPER_VERSION@">1</token>

    <xml name="stdio">
        <stdio>
            <exit_code range="1:" level="fatal" description="Error in Stacks execution" />
        </stdio>
    </xml>

    <xml name="citation">
        <citations>
            <citation type="doi">10.1111/mec.12354</citation>
            <citation type="doi">10.1111/mec.12330</citation>
            <citation type="doi">10.1534/g3.111.000240</citation>
            <citation type="doi">10.1534/genetics.111.127324</citation>
            <citation type="doi">10.1111/j.1755-0998.2010.02967.x</citation>
            <citation type="doi">10.1073/pnas.1006538107</citation>
        </citations>
    </xml>

    <xml name="version_cmd">
        <version_command><![CDATA[
        process_radtags -h |& grep process_radtags  | head -n 1 | cut -d" " -f 2
        ]]>
        </version_command>
    </xml>

    <token name="@STACKS_INFOS@">
<![CDATA[
--------

**Created by:**

Stacks was developed by Julian Catchen with contributions from Angel Amores, Paul Hohenlohe, and Bill Cresko

**Project links:**

`Stacks website <http://catchenlab.life.illinois.edu/stacks/>`_

`Stacks manual <http://catchenlab.life.illinois.edu/stacks/manual/>`_

`Stacks google group <http://groups.google.com/group/stacks-users>`_
]]></token>

    <xml name="enzymes">

        <option value="">Unspecified</option>
        <option value="aciI">aciI</option>
        <option value="ageI">ageI</option>
        <option value="aluI">aluI</option>
        <option value="apaLI">apaLI</option>
        <option value="apeKI">apeKI</option>
        <option value="apoI">apoI</option>
        <option value="aseI">aseI</option>
	<option value="bamHI">bamHI</option>
        <option value="bbvCI">bbvCI</option>
        <option value="bfaI">bfaI</option>
        <option value="bfuCI">bfuCI</option>
        <option value="bgIII">bgIII</option>
        <option value="bsaHI">bsaHI</option>
        <option value="bspDI">bspDI</option>
        <option value="bstYI">bstYI</option>
        <option value="cac8I">cac8I</option>
        <option value="claI">claI</option>
        <option value="csp6I">csp6I</option>
        <option value="ddeI">ddeI</option>
        <option value="dpnII">dpnII</option>
        <option value="eaeI">eaeI</option>
        <option value="ecoRI">ecoRI</option>
        <option value="ecoRV">ecoRV</option>
        <option value="ecoT22I">ecoT22I</option>
        <option value="haeIII">haeIII</option>
        <option value="hindIII">hindIII</option>
        <option value="hinP1I">hinP1I</option>
        <option value="hpaII">hpaII</option>
        <option value="kpnI">kpnI</option>
        <option value="mluCI">mluCI</option>
        <option value="mseI">mseI</option>
        <option value="mslI">mslI</option>
        <option value="mspI">mspI</option>
        <option value="ncoI">ncoI</option>
        <option value="ndeI">ndeI</option>
        <option value="nheI">nheI</option>
        <option value="nlaIII">nlaIII</option>
        <option value="notI">notI</option>
        <option value="nsiI">nsiI</option>
	<option value="nspI">nspI</option>
        <option value="pstI">pstI</option>
        <option value="rsaI">rsaI</option>
        <option value="sacI">sacI</option>
        <option value="sau3AI">sau3AI</option>
        <option value="sbfI">sbfI</option>
        <option value="sexAI">sexAI</option>
        <option value="sgrAI">sgrAI</option>
        <option value="speI">speI</option>
        <option value="sphI">sphI</option>
        <option value="taqI">taqI</option>
        <option value="xbaI">xbaI</option>
        <option value="xhoI">xhoI</option>
    </xml>

    <!-- log file handling -->
    <token name="@TEE_APPEND_LOG@"><![CDATA[
        #if $output_log
            2>> $output_log &&
        #end if
    ]]></token>
    <token name="@CAT_LOG_TO_STDERR@"><![CDATA[
        #if $output_log
            cat $output_log 2>&1 
        #end if
    ]]></token>
    <xml name="in_log">
        <param name="add_log" type="boolean" checked="false" truevalue="yes" falsevalue="no" label="Add log output as data set" />
    </xml>
    <xml name="out_log">
        <data format="txt" name="output_log" label="${tool.name} on ${on_string} log file">
            <filter>add_log</filter>
        </data>
    </xml>

    <!-- fastq input -->
    <xml name="fastq_input_macro" token_fastq_optional="false">
        <conditional name="input_type">
            <param name="input_type_selector" type="select" label="Short read data from individuals" help="Single end data or forward reads. If a paired list is provided only the forward reads are used in ustacks">
                <option value="manual" selected="true">single end or forward reads</option>
                <option value="list">(paired) data set list</option>
            </param>
            <when value="manual">
                <param name="samples" argument="-f" format="fastqsanger,fastqsanger.gz,fasta,fasta.gz" type="data" label="Reads" multiple="true" optional="@FASTQ_OPTIONAL@"/>
            </when>
            <when value="list">
                <param name="samples" argument="-f" type="data_collection" collection_type="list,list:paired" format="fastqsanger,fastqsanger.gz,fasta,fasta.gz" label="List for forward reads or read pairs" optional="@FASTQ_OPTIONAL@"/>
            </when>
        </conditional>
    </xml>
    <!-- requires a variable $read_direction=None|"forward"|"reverse" to be set 
         appends noting/.1/.2 to the link name for accessing the fastq data
         sets variables $name and $data_path-->
    <token name="@FASTQ_INPUT@"><![CDATA[
    #set $name = $clean_ext($sample.name)
    #set $data_path = "stacks_inputs/" + $name
    #if $sample.is_collection:
        #set $sample=$sample[$read_direction]
    #end if
    #if $read_direction == "forward":
        #set $data_path =  $data_path + ".1"
    #elif $read_direction == "reverse":
        #set $data_path =  $data_path + ".2"
    #end if
    #if $sample.is_of_type('fastqsanger')
        #set $data_path =  $data_path + ".fq"
        #set inputype = "fastq"
    #else if $sample.is_of_type('fastqsanger.gz')
        #set $data_path = $data_path + ".fq.gz"
        #set inputype = "gzfastq"
    #else if $sample.is_of_type('fasta')
        #set $data_path = $data_path + ".fa"
        #set inputype = "fasta"
    #else
        #set $data_path = $data_path + ".fa.gz"
        #set inputype = "gzfasta"
    #end if
    ln -s '$sample' '${data_path}' &&
    ]]></token>

    <!-- macro and token for BAM input-->
    <xml name="bam_input_macro">
        <param name="input_bam" format="bam" type="data" multiple="true" optional="false" label="BAM files" />
    </xml>
    <token name="@BAM_INPUT@"><![CDATA[
    #set $bamlist = ""
    #for $bam in $input_bam:
        #set $filename = $clean_ext($bam.element_identifier)+".bam"
        #if re.search('.*\.bam$', $filename)
            ln -s '$bam' bam_inputs/$filename &&
            #set bamlist += " -B 'bam_inputs/"+$filename+"'"
        #end if
    #end for
    ]]></token>

    <xml name="discover_faqgz_output_macro" token_pattern="" token_dir="">
        <expand macro="discover_faq_output_macro" pattern="@PATTERN@" dir="@DIR@"/>
        <discover_datasets pattern="@PATTERN@\.fq\.gz$" ext="fastqsanger.gz" directory="@DIR@/" />
        <discover_datasets pattern="@PATTERN@\.fa\.gz$" ext="fasta.gz" directory="@DIR@/" />
    </xml>
    <xml name="discover_faq_output_macro" token_pattern="" token_dir="">
        <discover_datasets pattern="@PATTERN@\.fq$" ext="fastqsanger" directory="@DIR@/" />
        <discover_datasets pattern="@PATTERN@\.fa$" ext="fasta" directory="@DIR@/" />
    </xml>
    <token name="@CLEAN_EXT@">
        <![CDATA[
        #from os.path import splitext
        #import re
        #def clean_ext($identifier)
            #while $identifier.endswith(('.1', '.2', '.fa', '.fq', '.fasta', '.fastq', '.gz', '.gzip', '.sam', '.bam'))
                #set $identifier = splitext($identifier)[0]
            #end while
$identifier#slurp
        #end def
        ]]>
    </token>

    <!-- tokens and macros for gapped alignment options 
         the _onoff macro gives an empty conditional (which is not so nice 
         but allows to be used also in the full macro) -->
    <token name="@GAP_OPTIONS@"><![CDATA[
#if $gapped.use_gapped == "yes"
    --max_gaps $gapped.max_gaps
    --min_aln_len $gapped.min_aln_len
#else
    --disable-gapped
#end if
]]></token>
    <token name="@GAP_OPTIONS_ONOFF@"><![CDATA[
#if $gapped.use_gapped != "yes"
    --disable-gapped
#end if
]]></token>
    <xml name="gap_options">
        <expand macro="gap_options_onoff">
            <param argument="--max_gaps" type="float" value="2.0" label="Number of gaps allowed between stacks before merging"/>
            <param argument="--min_aln_len" type="float" value="0.8" min="0.0" max="1.0" label="Minimum length of aligned sequence in a gapped alignment"/>
        </expand>
    </xml>
    <xml name="gap_options_onoff">
        <conditional name="gapped">
            <param name="use_gapped" argument="--disable-gapped" type="select" label="Perform gapped alignments between stacks">
                <option value="no">No</option>
                <option value="yes" selected="true">Yes</option>
            </param>
            <when value="no"/>
            <when value="yes">
                <yield/>
            </when>
        </conditional>
    </xml>

    <!-- ustacks outputs collection containing SAMPLE.tags.tsv, SAMPLE.snps.tsv, SAMPLE.alleles.tsv (SAMPLE!=catalog) -->
    <!-- TODO tags, snps, and alleles could go to sub collections -->
    <xml name="ustacks_outputs_macro" token_tooladd="">
        <collection name="tabs" type="list" label="${tool.name} @TOOLADD@ on ${on_string} Stacks">
            <discover_datasets pattern="(?P&lt;name&gt;(?!catalog).+\.tags)\.tsv$" ext="tabular" directory="stacks_outputs" />
            <discover_datasets pattern="(?P&lt;name&gt;(?!catalog).+\.snps)\.tsv$" ext="tabular" directory="stacks_outputs" />
            <discover_datasets pattern="(?P&lt;name&gt;(?!catalog).+\.alleles)\.tsv$" ext="tabular" directory="stacks_outputs" />
        </collection>
    </xml>
    <!-- cstacks outputs collection containing catalog.tags.tsv, catalog.snps.tsv, catalog.alleles.tsv -->
    <xml name="cstacks_outputs_macro" token_tooladd="">
        <collection name="catalog" type="list" label="${tool.name} @TOOLADD@ on ${on_string} Catalog">
            <discover_datasets pattern="(?P&lt;name&gt;catalog\.(tags|snps|alleles))\.tsv$" ext="tabular" directory="stacks_outputs" />
        </collection>
    </xml>
    <!-- sstacks outputs collection containing SAMPLE.matches.tsv -->
    <xml name="sstacks_outputs_macro" token_tooladd="">
        <collection name="matches" type="list" label="${tool.name} @TOOLADD@ on ${on_string} Matches to the catalog">
            <discover_datasets pattern="(?P&lt;name&gt;.+\.matches)\.tsv$" ext="tabular" directory="stacks_outputs" />
        </collection>
    </xml>
    <!-- tsv2bam outputs collection containing SAMPLE.matches.bam -->
    <xml name="tsv2bam_outputs_macro" token_tooladd="">
        <collection name="bams" type="list" label="${tool.name} @TOOLADD@ on ${on_string} Stacks">
            <discover_datasets pattern="(?P&lt;name&gt;.+\.matches)\.bam$" ext="bam" directory="stacks_outputs" />
        </collection>
    </xml>
    <!-- gstacks outputs collection containing catalog.calls.vcf and catalog.fa.gz -->
    <xml name="gstacks_outputs_macro" token_tooladd="">
        <collection name="gstacks_out" type="list" label="${tool.name} @TOOLADD@ on ${on_string}">
            <discover_datasets pattern="(?P&lt;name&gt;catalog\.calls\.vcf)$" ext="vcf" directory="stacks_outputs" />
            <discover_datasets pattern="(?P&lt;name&gt;catalog\.fa\.gz)$" ext="fasta.gz" directory="stacks_outputs" />
        </collection>
    </xml>

    <!-- default output of populations -->
    <xml name="populations_output_light" token_tooladd="">
        <data format="tabular" name="out_haplotypes" label="${tool.name} @TOOLADD@ on ${on_string} Raw Genotypes/Haplotypes" from_work_dir="stacks_outputs/populations.haplotypes.tsv" />
        <data format="tabular" name="out_hapstats" label="${tool.name} @TOOLADD@ on ${on_string} Population-level haplotype summary statistics" from_work_dir="stacks_outputs/populations.hapstats.tsv" />
        <data format="txt" name="out_populations_log_distribs" label="${tool.name} @TOOLADD@ on ${on_string} Populations log distributions" from_work_dir="stacks_outputs/populations.log.distribs" />
        <data format="tabular" name="out_sumstats_sum" label="${tool.name} @TOOLADD@ on ${on_string} Summary of Population-level summary statistics" from_work_dir="stacks_outputs/populations.sumstats_summary.tsv" />
        <data format="tabular" name="out_sumstats" label="${tool.name} @TOOLADD@ on ${on_string} Population-level summary statistics" from_work_dir="stacks_outputs/populations.sumstats.tsv" />
        <data format="tabular" name="out_sql" label="${tool.name} @TOOLADD@ on ${on_string} Genotyping markers" from_work_dir="stacks_outputs/populations.markers.tsv" />
    </xml>

    <xml name="populations_output_full">
        <expand macro="populations_output_light"/>

        <!-- log_fst_comp	populations.fst_summary.tsv	populations.phistats_summary.tsv	populations.phistats.tsv-->
        <data format="tabular" name="out_phistats" label="${tool.name} on ${on_string} Phi_st statistics" from_work_dir="stacks_outputs/populations.phistats.tsv">
            <filter>advanced_options['log_fst_comp'] and fstats_conditional['fstats']=='yes'</filter>
        </data>
        <data format="tabular" name="out_phistats_sum" label="${tool.name} on ${on_string} Summary of Phi_st statistics" from_work_dir="stacks_outputs/populations.phistats_summary.tsv">
            <filter>advanced_options['log_fst_comp'] and fstats_conditional['fstats']=='yes'</filter>
        </data>
        <data format="tabular" name="out_fststats_sum" label="${tool.name} on ${on_string} Summary of Fst statistics" from_work_dir="stacks_outputs/populations.fst_summary.tsv">
            <filter>advanced_options['log_fst_comp'] and fstats_conditional['fstats']=='yes'</filter>
        </data>

        <!-- fasta_loci	populations.loci.fa
             fasta_samples	populations.samples.fa
             fasta_samples_raw	populations.samples-raw.fa-->
        <data format="tabular" name="out_fasta_strict" label="${tool.name} on ${on_string} per-locus consensus sequences" from_work_dir="stacks_outputs/populations.loci.fa">
            <filter>populations_output['fasta_loci']</filter>
        </data>
        <data format="tabular" name="out_fasta" label="${tool.name} on ${on_string} per-locus, per-haplotpye sequences" from_work_dir="stacks_outputs/populations.samples.fa">
            <filter>populations_output['fasta_samples']</filter>
        </data>
        <data format="tabular" name="out_fasta_raw" label="${tool.name} on ${on_string} per-locus, per-haplotpye sequences (regardless of biological plausibility)" from_work_dir="stacks_outputs/populations.samples-raw.fa">
            <filter>populations_output['fasta_samples_raw']</filter>
        </data>

        <!-- phylip	populations.fixed.phylip	populations.fixed.phylip.log
             phylip_var	populations.var.phylip	populations.var.phylip.log-->
        <data format="tabular" name="out_phylip_all_pop_fix" label="${tool.name} on ${on_string} Phylip nucleotides that are fixed-within, and variant among populations" from_work_dir="stacks_outputs/populations.fixed.phylip">
            <filter>populations_output['phylip']</filter>
        </data>
        <data format="tabular" name="out_phylip_all_loci_fix" label="${tool.name} on ${on_string} Phylip (loci) nucleotides that are fixed-within, and variant among populations" from_work_dir="stacks_outputs/populations.fixed.phylip.log">
            <filter>populations_output['phylip']</filter>
        </data>
        <data format="tabular" name="out_phylip_all_pop_var" label="${tool.name} on ${on_string} Phylip all sequence as well as variable sites" from_work_dir="stacks_outputs/populations.var.phylip">
            <filter>populations_output['phylip_var']</filter>
        </data>
        <data format="tabular" name="out_phylip_all_loci_var" label="${tool.name} on ${on_string} Phylip (loci) all sequence as well as variable sites" from_work_dir="stacks_outputs/populations.var.phylip.log">
            <filter>populations_output['phylip_var']</filter>
        </data>

        <!-- genepop	populations.haps.genepop populations.snps.genepop -->
        <data format="tabular" name="out_genepop_snps" label="${tool.name} on ${on_string} SNPs in GenePop format" from_work_dir="stacks_outputs/populations.snps.genepop">
            <filter>populations_output['genepop']</filter>
        </data>
        <data format="tabular" name="out_genepop_haps" label="${tool.name} on ${on_string} Haplotypes in GenePop format" from_work_dir="stacks_outputs/populations.haps.genepop">
            <filter>populations_output['genepop']</filter>
        </data>

        <!-- vcf	populations.haps.vcf populations.snps.vcf -->
        <data format="vcf" name="out_vcf_haplotypes_snps" label="${tool.name} on ${on_string} SNPs in VCF format" from_work_dir="stacks_outputs/populations.snps.vcf">
            <filter>populations_output['vcf']</filter>
        </data>
        <data format="vcf" name="out_vcf_haplotypes_haps" label="${tool.name} on ${on_string} Haplotypes in VCF format" from_work_dir="stacks_outputs/populations.haps.vcf">
            <filter>populations_output['vcf']</filter>
        </data>

        <!--plink	populations.plink.map populations.plink.ped-->
        <data format="tabular" name="out_plink_markers" label="${tool.name} on ${on_string} PLINK (makers)" from_work_dir="stacks_outputs/populations.plink.map">
            <filter>populations_output['plink']</filter>
        </data>
        <data format="tabular" name="out_plink_genotypes" label="${tool.name} on ${on_string} PLINK format (genotypes)" from_work_dir="stacks_outputs/populations.plink.ped">
            <filter>populations_output['plink']</filter>
        </data>

        <!--structure	populations.structure-->
        <data format="tabular" name="out_structure" label="${tool.name} on ${on_string} Structure format" from_work_dir="stacks_outputs/populations.structure">
            <filter>populations_output['structure']</filter>
        </data>

        <!-- radpainter	populations.haps.radpainter -->
        <data format="tabular" name="out_radpainter" label="${tool.name} on ${on_string} Radpainter format" from_work_dir="stacks_outputs/populations.haps.radpainter">
            <filter>populations_output['radpainter']</filter>
        </data>

    </xml>

    <xml name="snp_options_alpha">
        <param argument="--alpha" type="select" label="Chi square significance level required to call a heterozygote or homozygote" >
            <option value="0.1">0.1</option>
            <option value="0.05" selected="True">0.05</option>
            <option value="0.01">0.01</option>
            <option value="0.001">0.001</option>
        </param>
    </xml>

    <xml name="snp_options">
        <conditional name="select_model">
            <param argument="--model_type" type="select" label="Choose the model">
                <option value="snp" selected="true">SNP</option>
                <option value="bounded">Bounded SNP</option>
                <option value="fixed">Fixed</option>
            </param>
            <when value="snp">
                <expand macro="snp_options_alpha"/>
            </when>
            <when value="bounded">
                <param argument="--bound_low" type="float" value="0.0" min="0.0" max="1.0" label="lower bound for epsilon, the error rate" help="between 0 and 1.0"/>
                <param argument="--bound_high" type="float" value="1.0" min="0.0" max="1.0" label="upper bound for epsilon, the error rate" help="between 0 and 1.0" />
                <expand macro="snp_options_alpha"/>
            </when>
            <when value="fixed">
                <yield/>
            </when>
        </conditional>
    </xml>
    <xml name="snp_options_full">
        <expand macro="snp_options">
            <param argument="--bc_err_freq" type="float" value="0.1" min="0.0" max="1.0" label="Barcode error frequency" help="between 0 and 1.0"/>
        </expand>
    </xml>

    <!-- variant calling option for use in gstacks and denovomap -->
    <xml name="variant_calling_options_vg">
        <param argument="--var-alpha" name="var_alpha" type="float" value="0.05" min="0" label="alpha threshold for discovering SNPs" />
        <expand macro="variant_calling_options_g"/>
    </xml>
    <xml name="variant_calling_options_g">
        <param argument="--gt-alpha" name="gt_alpha" type="float" value="0.05" min="0" label="alpha threshold for calling genotypes" />
    </xml>

    <xml name="barcode_encoding_single">
        <option value="--inline_null" selected="True">Barcode is inline with sequence, occurs only on single-end read</option>
        <option value="--index_null">Barcode is provded in FASTQ header (Illumina i5 or i7 read)</option>
        <yield/>
    </xml>

    <xml name="barcode_encoding_pair">
        <expand macro="barcode_encoding_single">    
            <option value="--null_index">barcode is provded in FASTQ header (Illumina i7 read if both i5 and i7 read are provided)</option>
            <option value="--inline_inline">barcode is inline with sequence, occurs on single and paired-end read</option>
            <option value="--index_index">barcode is provded in FASTQ header (Illumina i5 and i7 reads).</option>
            <option value="--inline_index">barcode is inline with sequence on single-end read and occurs in FASTQ header (from either i5 or i7 read)</option>
            <option value="--index_inline"></option>
        </expand>    
    </xml>
</macros>
